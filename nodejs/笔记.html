<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!--
        nodejs:单线程，多进程，非阻塞IO，事件驱动
            ----默认：单进程，单线程
            ----可以变成多进程
        1.node.js安装
        2.区别，与其他后台语言的区别
        3.npm-----nodejs的包管理器
        优点：
            ----对象，语法和js一样，但使用习惯不同，前端注重交互，后台注重性能安全性等
            ----性能不错，与php等相比，性能不错，因为运行环境是chrome v8引擎，做预编译性能很高
            ----前后台配合起来方便
        缺点：
            ----没有丰富的库支持
        用处：
            ----1.做服务器，小型项目  2.做中间层--先请求nodejs ,nodejs请求后台，这样一般是大型项目的使用，可提升性能，安全性，和前台交互方便
            ----2.测试，构建工具grunt,gulp,webpack等，抓取数据

        3.搭建服务器
        ---服务器一般是异步处理
            1.----使用nodejs搭建web服务器，也必须遵守http协议
            2.----只有js文件
                ----和js一样，是单线程，单进程
                ----cmd命令行运行  node  xxx.js
            3.----nodejs中的模块，其严重依赖模块去实现功能
                ----http模块
                ----1.引入模块  const http=require('http');
                ----2.创建服务器(http模块有创建的方法API) let server=http.createServer((request,response)=>{...}) 只要访问此服务器就会触发回调
                        ----let server=http.createServer((request,response)=>{
                            //request  请求  接收到的数据   方法   request.method请求方式Get Post   request.url请求的地址 
                            //response   响应   发送出去的数据  方法  response.write('aaa')写数据   
                            //response.end()表示发送的数据已发完，否则浏览器会以为没发完，如果服务器端没有数据返回到客户端 那么就可以用 res.end，快速结束响应处理流程
                                response.write('aaaa');
                                response.end();
                        })
                        ----在浏览器页面可查看发送的数据
                ----3.监听服务器，否则程序将会变成关闭，因为服务器不能一开一关，且说明监听哪个服务器(端口号)
                    ----server.listen(8888)---监听端口号8888的服务器
                    ----1.可在浏览器中进行访问localhost:8888端口号，触发nodejs的http模块
                    ----2.启动nodejs文件，启动服务器,此时因为是进行监听，故服务将不会结束，出现光标可在终端查看结果
                    ----其中也存在默认端口，根据协议
                        ----http: 80
                        ----ftp: 21
                        ----mysql: 3306

            4.nodejs中的常见其他模块 
                ----Assertion Testing ---断言----表示绝对不会出现的那种情况
                        -----assert(条件，'对条件的叙述一段话')  assert(arguments.length==2,'必须传两个参数')--必须传递两个参数，否则就不行
                        -----assert( typeof a=='number','第一个参数必须是数字')

                ----Buffer  帮助nodejs处理二进制的数据，例如传过来的图片，可以和fs模块配合使用

                ----file system  文件系统，书写，读取
                    
                    ---fs.writeFile  书写文件
                        ---fs.writeFile('写的文件名2.txt','写的文件的内容222',err=>{
                            //err:错误信息
                        })
                    ---fs.readFile   读取文件---会先将数据全部读完后并保存在内存中，才进行回调
                                            ----及其浪费内存，资源利用及其不合理
                        ---fs.readFile('读取的文件1.txt(或者直接写路径www/1.html)',(err,data)=>{   ------必须要err,data--顺序不能颠倒
                            //err：错误信息
                            //data:读取文件的内容---输出的是二进制数据，输出Buffer对象
                            //data=>变成内容，而不是二进制  data.toString()----必须确定是文本文件 如果是png jpg等文件，使用data.toString()将会报错
                        })

                ----c++ Addons模块  
                    ----应用场景：需要nodejs的方便性，同时也需要c/c++的性能（c语言的性能与其他语言相比根本没有可比性），可以通过c/c++书写一些插件给nodejs使用


                ----child Processes,Cluster,Process 这三个模块可实现js的多进程，不是多线程
                    ----Node.js默认单进程运行，对于32位系统最高可以使用512MB内存，对于64位最高可以使用1GB内存，
                        --对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置。cluster模块就是为了解决这个问题而提出的。
                    ----因为js是单线程，单进程,一个程序中有多个进程，一个进程里有多个线程并行工作
                        ----进程：拥有独立，存储的执行空间
                        ----线程：同一个进程内的所有线程共享一套空间，代码
                        ----多进程(PHP,Node)：缺点：成本高（申请时间，分配时间）（慢，但安全，因为之间是隔离的），进程之间通信麻烦，写代码简单
                        ----多线程(java,C)：成本低（快，但不安全，线程一死都得死），线程间通信会容易些，写代码复杂

                ----ECMAscript Moudle,Moudle  指的是nodejs中的模块化系统，简单说并不能说是一个模块
                
                ----Command Line Options  通过命令行传递的参数  

                ----Crypto  帮助nodejs完成加密---签名
                    ----签名算法   md5  sha
                    ----理论上的绝对加密：  一次一密，密钥长度>内容长度
                        ----目前最安全，最广泛的加密方式：RSA

                ----HTTP/HTTPS  HTTP/2

                ----OS 帮助提供系统的信息，运行情况，cpu，内存
                    ----os.cpus()----cpu的情况

                ----Path 处理文件路径等
                    ----path.parse()----解析路径 '/var/test/local/1.png'
                    ----path.dirname(str)---目录名称 /var/test/local
                    ----path.basename(str)----文件名 1
                    ----path.extname(str)----拓展名 .png

                ----Events事件队列
                    ----所有能触发事件的对象都是 EventEmitter 类的实例。 这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上。
                    ----类似于数据加载完成等的事件
                    ----最初解决async异步
                    ----可解决函数的耦合，类似于js中的事件监听器

                ----Query Strings
                    ----地址栏中的？后面的字符串
                    ----解析地址栏中的？后面的字符串---返回一个对象
                ----URL
                    ----整个地址栏的字符串
                    ----解析整个地址栏中的字符串---返回一个对象
                    ----已经包括了querystring模块
                        ----let obj=url.parse('.....',true)---添加true

                ----网络模块
                    ----TCP，UDP协议---通用的协议
                    ----TCP：稳定----node中使用Net模块使用此协议
                    ----UDP：快----node中使用UDP/Datagram模块使用此协议

                ----DNS
                    ----域名解析
                        ----1.地址解析成ip(baidu.com=>120.54.26.38)(其中通过根DNS服务器解析)
                        
                ----Stream(流操作)
                    ----连续数据都是流，视频流，网络流，文件流，语法流
                    ----流（stream）是 Node.js 中处理流式数据的抽象接口。 stream 模块用于构建实现了流接口的对象。

                ----TLS/SSL协议
                    ----加密，安全

                ----TTY
                    ----终端
                
                ----ZLIB
                    ----gz压缩

                ----node-uuid
                    ----UUID是通用唯一识别码的缩写，其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息。
                        UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。
                    ----安装  cnpm i node-uuid
                    ----引用 const uuid=require('node-uuid');
                        ----uuid.v1()--是基于时间的uuid，通过计算当前时间戳、随机数和机器MAC地址得到。
                        ----uuid.v4()--根据随机数，或者伪随机数生成UUID

            5.搭建服务器
                ----1.搭建基本服务器
                ----2.将相关内容保存在磁盘中，否则一个文件里有所有的内容，此时服务就会不稳定，且修改一次服务将重启一次
                        ----将相关内容保存在磁盘中，当访问到某一个页面链接时，直接读取磁盘中的文件即可，方便

            6.nodejs的数据交互 post get
                ----阻塞IO----IO进行期间，程序是不能动的，除非程序已经完成
                ----非阻塞IO----(nodejs)IO进行期间，程序会向下执行的，并不会等待
                ----Get---url地址栏中，大小32k
                ----Post---作为内容body传输，大小1G
                ----前台请求
                        ---get
                        1.设置response.writeHeader(404).设置status值，找不到文件时可以设置404
                        2.先规定前台提交数据的地址，例如表单<form action='http://localhost:8080/aaa'></form>
                        3.启动监听localhost:8080的服务器，通过resquest.url获取get请求的数据
                        4.通过监听request.on('data',data=>{}); request.on('end',()=>{});在数据包到达时和结束时触发获取到整个的数据
                            ----get,post都会触发req.on('data',data=>{})----因为req.on()是监听请求
                
                ----接口：前台和数据库的中间人，如果没有这个中间人，那么数据库中将会乱套，暴露数据库的用户和密码
                ----登陆注册简易接口
                        ----简易方法：可通过switch--case设置request.url的各种情况(登陆，注册)
                            ----登陆----后台进行校验数据
                            ----注册----后台进行校验数据
            
            7.数据库
                1.----关系数据库--MySQL，Oracle
                        -----最常见，最常用的
                        -----数据之间存在关系
                        -----MySQL---性能高，安全性高,但容灾能力差
                        -----Oracle---适合金融，医疗，容灾能力强
                2.----文件型数据库--sqlite
                        -----简单，体积小
                        -----不擅长处理大型数据
                        -----擅长保存数据不大，且要求简单
                3.----文档型数据库--MongoDB
                        -----直接存储异构数据，例如可以直接将json直接存储在里面
                        -----方便
                4.NoSQL和SQL
                        ----SQL----性能略差
                        ----NoSQL----没有复杂的关系，但对性能有极高的要求,强调的是快
                                -----radis,memcached,hypertable,bigtable

                5.数据仓库
                        ----海量的数据

            8.nodejs的垃圾回收
                ----垃圾回收：只要某个东西不再使用了，就释放掉占用的内存
                    ----基本原理：判断某个变量或者对象啥的，引用的次数是否等于0，如果引用一次后，将此变量啥的设置为null，
                                    此时之后的引用次数将会被判断为0次，此时将会进行回收
                ----内存泄漏：例如c语言，需要手动的分配内存，不使用后需要手动的释放内存，当忘记释放内存时，
                        就会造成这一块的内存永远不够，内存泄漏的越来越多，程序将会运行不下去，一般高级语言
                        就会自动进行垃圾回收，不需要手动

            9.nodejs的文件上传
                ----表单的file上传-----post方式
                    ----  <form action="http://localhost:8088" method="post" enctype="text/plain">
                            ---- enctype="text/plain"----上传的是纯文本，没有任何结构可言
                            ---- enctype="application/x-www-form-urlencoded"-----上传的是url编码，一般是名字啥的
                                    ----默认的上传方式，xxx=xxx&xxx=xxx...
                            ---- enctype="multipart/form-data"----上传的是文件内容，但是一般是将数据进行切块
                ----nodejs文件上传的步骤
                    ----1.当在end事件中接收到数据时，此时将会是一个Buffer对象，因为当二进制数据传过来时(图片)时，只能将之保存在Buffer对象中
                    ----2.对Buffer对象做出处理，得到里面的详细数据
                        ----1.单独在Buffer的原型上添加split方法，因为Buffer并没有split方法
                        ----2.在需要使用的文件中引入此单独写的公共方法split
                        ----3.处理Buffer
                            ----1.通过分配符切割每一个Buffer，将之变成几个数据的整合数组
                            ----2.去掉大数组的首尾元素，第一个是favicon.icon请求时出现的Buffer,最后一个是结尾符--
                            ----3.去掉每个数据项的首尾的\r\n
                            ----4.再通过\r\n\r\n切割数据，将数据描述和数据值整合成一个数组
                            ----5.切割成两半后，单独对大数组里面的每个小数组进行操作，提取数据描述和数据值
                                ----同时在其中通过查找数据描述后面是否存在\r\n来判断是否是普通数据还是文件数据
                                ----普通数据就直接获取，将之保存在一个早已定义的变量中
                                ----文件数据此时拿到filename,name,content-type后，还需要对文件内容做出处理
                                    -----文件内容是Buffer对象，将前台传过来的数据保存在后台
                                    -----通过fs文件系统书写复制文件，同时使用uuid将文件名设置成随机数，这样才能几乎不会和任何文件重复，

                    ----3.改进（流操作）
                        ---改进：收到一部分，解析一部分（目前：接收数据全部完成后才进行解析）
                        ---流操作：收到一部分，就处理一部分
                            ---1.读取流  fs.createReadStream('1.txt')
                            ---2.写入流  fs.createWriteStream('1.txt')
                            ---其中流的流向：读取流流向写入流
                                ---rs.pipe(ws)

                            ---3.读写流（有进有出）   :压缩，加密，在rs开始，过程是'压缩'，最后在ws结束
                        ---网络中的流：
                            ---1.创建服务器后，其中的req，res都是一个流；req读取流，res写入流
                            ---2.当创建读取流后，可通过rs.on('error')--监听读取中的错误
                                    ---可通过ws.on('finish')--监听写入完成
                            ---3.将读取的数据进行压缩后再进行传输(gz压缩)，可提升性能,节约带宽
                                    ---res.setHeader('content-encoding','gzip')
                                    ---设置content-Encoding:gzip  

            
            10.nodejs的缓存
                        ----优点：可以保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。极大的节省内存资源，节省带宽
                        ----请求相同的资源时，会将资源保存在缓存中，如果再次请求时，文件没有变化，浏览器将直接从缓存中取302，否则将会再次请求后台200
                        ----1.第一次请求时，服务端需要告诉客户端
                            ------在Response-Headers中Last-Modified:Sat,02  Dec 2020 04:03:14  GMT
                                 （服务端告诉客户端第一次文件修改的日期）
                        ----2.浏览器向服务端请求时
                            ---在Request-Header中If-Modified-Since:Sat,02  Dec 2020 04:03:14  GMT
                                    (请求相同的资源时,如果再次请求时，如果文件没有变化，前台就告诉后台不用发，否则就再发一份)
                                    ---会和Last-Modified的时间进行比较，如果时间一致，就代表文件没有进行修改，直接从缓存中提取，
                                    ---如果时间不一致，表示文件被修改了，此时浏览器将丢弃旧版本，缓存新版本，即重新请求一次
                        ----3.服务端给浏览器返回时
                            ---200//304

                        ----缓存策略--cache-control
                            ----决定是否缓存，缓存方式

            11.nodejs的进程
                        ----1.安全，性能高（充分利用了CPU的资源）
                        ----2.普通的程序并不能创建进程，只有系统进程才能创建进程；
                        ----3.进程是分裂出来的，并且执行的是同一套代码----且只有主进程才能分裂，子进程不能分裂
                        ----4.父子进程之间可以共享“句柄”（代表对某种资源占用的权限）----且可以共享一个端口
                        ----5.合理的利用CPU的资源
                            ----有多少个内核，就开启几个进程；（有几个内核，同时执行的进程就只有几个）

            12. nodejs的全局对象
                        ----JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。
                            在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）
                            都是 global 对象的属性。
                        ----注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。
        
                    -->
</body>
</html>